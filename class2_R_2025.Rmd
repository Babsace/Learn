---
title: "class2_R_2025"
author: "Babatunde Oyedele_101385"
date: "2025-10-16"
output: html_document
---

# Data Visualization and Data management

# Test to treat data
```{r}
data1<- read.table(text="Sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
1 4 6 30 140 67 47 23 39 134 80
2 10 2 29 164 72 81 28 63 211 132",header=TRUE) 

barplot(as.matrix(data1),main="Confirmed cases Vs Gender",beside=TRUE,col=c("gold3","red"))

legend("topright", c("Male","Female"),cex = 0.8,bty="n",fill = c("gold3","red"))
```

```{r}
data3<- read.table(text="sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
867 582 1802 12003 3059 9205 5346 7269 5933 324
842 436 1805 11785 3508 10908 4902 7883 5901 464",header=TRUE)

barplot(as.matrix(data3),main=" COVID 19 test Vs Gender",beside=TRUE,col=c("blue","purple"))
legend("topleft", c("Male","Female"),cex = 1.3,bty="n",fill = c("blue",
"purple"))
```

```{r}
data2<- read.table(text="Sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
0 0 1 9 8 7 1 4 11 22
11 3 41 242 104 78 44 86 244 147
3 5 17 53 27 43 6 12 90 43 ",header=TRUE)
barplot(as.matrix(data2),main="Confirmed cases Vs Age categories",beside=TRUE,col=c("green","blue","purple"))
barplot(as.matrix(data2),main="Confirmed cases Vs Age categories",beside=TRUE,col=c("green","blue","purple"))
legend("topleft", c("Less than 15 years","15-49 years","Above 50"),cex = 1.3,bty="n",fill = c("green","blue","purple"))
```
# This is a line chart (specifically a multiple line chart or comparison line chart).
```{r}
months<-c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023")
Confirmed_covid<-c(14,8,59,304,139,128,51,102,345,212)
plot(Confirmed_covid, type = "l",pch=21, col = "red",ylim=c(0,350),
 xaxt="n", ylab = "Number of patients ",
 main = "Confirmed cases Vs treatment ")
treatment<- c(12,0,26,217,104,57,12,47,23,20)
lines(treatment, col="blue",lty=2)
 
legend("topleft", legend=c("Received treatment", "Confirmed"),cex=0.5,
fill = c("blue","red"))
axis(1,at=1:10,lab=c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan
 _2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023"))
```

# line chart
```{r}
months<-c("sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","feb_2023","Mar_2023","Apr_2023","May_2023", "June_2023")
number_of_test<-c(1709, 1018, 3607,23788,6567,20113,10248,15152,11834,7891)
plot(number_of_test, type = "o", col = "blue",ylim=c(0,24000),
 xaxt="n", ylab = "Number of Test",
 main = "COVID 19 Test")
axis(1,at=1:10,lab=c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023"))
```

# ggplot2

 ggplot2 provides a set of tools that allows you to visualize complex data sets in a
 new creative way-some work need some packages to get done.some of the graph
 are created using R’s base graphics system

# Library ggplot2
```{r}
###install.packages("ggplot2")
 library(ggplot2)
```


# let us explore the data mcars
```{r}
data(mtcars)
#dotchart(mtcars$mpg,labels=row.names(mtcars),ce#x = 0.,main="miles per Gallon of car #model",xlab = "MPG")
 
table(mtcars$cyl)
 ##
 ## 4 6 8
 ## 11 7 14
#barplot(mtcars$cyl)
barplot(table(mtcars$cyl),main="Distribution of car Cylinder counts",xlab="Number of cylinders",ylab = "Number of cars")
```

```{r}
barplot(table(mtcars$cyl),main="Distribution of car Cylinder counts",xlab="Number of cylinders",ylab = "Number of cars",horiz=TRUE)
```
# Scatter Plot
```{r}
plot(mtcars$mpg~mtcars$wt,main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")
```

```{r}
plot(mtcars$mpg~mtcars$wt,main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")

plot(mtcars$mpg~mtcars$wt,pch=17,main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")
```

```{r}
plot(mtcars$mpg~mtcars$wt,pch=21,main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")
```

```{r}
plot(mtcars$mpg~mtcars$wt,type="l", lty=2, lwd=2,col="red",main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")
```


# in ggplot2, plots are created by chaining together function using (+)sign. Each function modify the

## plot created up to that point
```{r}
library(ggplot2)
ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point()+
  labs(title = "Automobile Data",x="Weight",y="Miles per Galon")
```
# Scatter Plot with Regression Line

```{r}
ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point(pch=17,color="blue",size=1)+
 geom_smooth(method="lm",color="green")+
 labs(title = "Automobile Data",x="Weight",y="Miles per Galon")
 
## `geom_smooth()` using formula = 'y ~ x'
```
# Scatter Plot with Regression Line
```{r}
f0<-ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point(shape=24, fill=1,size=1)+
 geom_smooth(method="lm",color="blue")
 f0
 ## `geom_smooth()` using formula = 'y ~ x'
```

```{r}
f1<-f0+theme_bw()
 f1
 ## `geom_smooth()` using formula = 'y ~ x'
```

```{r}
f2<-f1+
 theme(panel.grid = element_line(linetype = "dotted",color = "Black"))
 f2
 ## `geom_smooth()` using formula = 'y ~ x'
```

# Grouping displays two or more groups of observations in a single plot

```{r}
data(mtcars)

mtcars$am<-factor(mtcars$am, levels =c(0,1),
 labels= c("Automatic","Manual"))
mtcars$vs<-factor(mtcars$vs, levels =c(0,1),
 labels=c("V-Engine","Straight Engine"))
mtcars$cyl<-factor(mtcars$cyl)
ggplot(data=mtcars,aes(x=hp,y=mpg,shape=cyl,color=cyl))+
 geom_point(size=3)+
 facet_grid(vs~am)+
 labs(title = "Automobile Data by Engine Type",x="HorsePower",y="Miles per Gallon")

```

```{r}
data(singer,package="lattice")
ggplot(singer,aes(x=voice.part,y=height))+geom_boxplot()
```
# Use the following function:
 geom_bar()geom_boxplot()geom_density()geom_histogram()geom_hline()
 geom_jitter()geom_line()#geom_point()geom_rug()#geom_smooth()geom_text()
 geom_violin()geom_vline()##Basicdatamanagement
 
# cbind and rbind
While combining column wise,the number of rows must match but row names are ignored.when combining row-wise,both the number and the names of columns must match.
 
```{r}
data2<-data.frame(x=1:3,y=c("a","b","c"))
str(data2)
 ##'data.frame': 3obs.of 2variables:
 ## $x:int 123
 ## $y:chr "a""b""c"
(cbind(data2,data.frame(z=3:1)))
 ## xyz
 ##11a3
 ##22b2
 ##33c1
(rbind(data2,data.frame(x=10,y="z")))
 ## xy
 ##1 1a
 ##2 2b
 ##3 3c
 ##410z
```
#  Create another Variable
```{r}
# Read the data
data_class <- read.csv("C:\\Users\\tunsm\\Downloads\\AUCA\\R programming\\dbms_data.txt")

# Check variable names in the dataset
variable.names(data_class)

# View first 5 rows
head(data_class, n=5)

# View last few rows
tail(data_class)

# View first column (StudentID)
data_class[,1]

# Summary of DatabaseScore
summary(data_class$DatabaseScore)

# Length of DatabaseScore column
length(data_class$DatabaseScore)

# View all columns except first one
data_class[,-1]

# Attach the dataset for easier variable access
attach(data_class)

# Calculate a performance score instead of BMI (using available columns)
# Example: Combine DatabaseScore and ProjectsCompleted
(PerformanceScore <- (DatabaseScore + (ProjectsCompleted * 5)) / 2)

# Round the performance score
(PerformanceScore <- round((DatabaseScore + (ProjectsCompleted * 5)) / 2, digits = 1))

# View first few rows with the new PerformanceScore
head(cbind(data_class, PerformanceScore))

# View last 10 rows with the new PerformanceScore
tail(cbind(data_class, PerformanceScore), n=10)

# Detach the dataset
detach(data_class)
```

# Summary of BMI
```{r}
summary(DatabaseScore)

hist(data_class$DatabaseScore)
```

```{r}
hist(data_class$DatabaseScore,col = "blue",main = "Sample Histogram")
```

```{r}
 stem(DatabaseScore,scale=2)
```


# Subsetting

# Useof$,[].or[[]]
  
Creation of leadership data Interest:How men and women differ in the way they
lead their organizations.5 questions were asked in this study.Example of the
question:Do men and women in management position differ in the degree to which
they defer to superiors? 1: strongly disagree, 2: disagree, 3: neither agree nor
disagree,4: agree,5: strongly agree

```{r}
manager<-c(1,2,3,4,5)
country<-c("US","US","UK","UK","UK")
gender<-c("M","F","F","M","F")
age<-c(32,45,25,39,99)
q1<-c(5,3,3,3,2)
q2<-c(4,5,5,3,2)
q3<-c(5,2,5,4,1)
q4<-c(5,5,5,NA,2)
q5<-c(5,5,2,NA,1)
leadership<-data.frame(manager,country,gender,age,q1,q2,q3,q4,q5,stringsAsFactors=FALSE)
leadership<-data.frame(manager,country,gender,age,q1,q2,q3,q4,q5)
 str(leadership)
 ##'data.frame': 5obs.of 9variables:
 ## $manager:num 12345
 ## $country:chr "US""US""UK""UK"...
 ## $gender:chr "M""F""F""M"...
 ## $age :num 3245253999
 ## $q1 :num 53332
 ## $q2 :num 45532
 ## $q3 :num 52541
## $q4 :num 555NA2
 ## $q5 :num 552NA1
names(leadership)
 ##[1]"manager""country""gender" "age" "q1" "q2" "q3"
 ##[8]"q4" "q5"
```

What you can do - combine the score of the five questions - hand let he missing
values-create a dataset of what you want-create age group or age categories - 99 indicate the value i missing

# Missingvalue
```{r}
leadership$age[leadership$age==99]<-NA

leadership$agecat[leadership$age>75]<-"Elder"
leadership$agecat[leadership$age>=35&leadership$age<=75]<-"MiddleAged"
leadership$agecat[leadership$age<35]<-"Young"
```

One way to handle missing value
 
Deleting all observations with missing data(Listwise deletion)is one of the several methods of handling incomplete datasets.Note:You can also replacing the missing value by the average of the remaining data.

```{r}
is.na(leadership[,5:9])
 ## q1 q2 q3 q4 q5
 ##[1,]FALSEFALSEFALSEFALSEFALSE
 ##[2,]FALSEFALSEFALSEFALSEFALSE
 ##[3,]FALSEFALSEFALSEFALSEFALSE
 ##[4,]FALSEFALSEFALSE TRUE TRUE
 ##[5,]FALSEFALSEFALSEFALSEFALSE
 newdata<-na.omit(leadership)
 newdata
 ## managercountrygenderageq1q2q3q4q5 agecat
 ##1 1 US M 32 5 4 5 5 5 Young
 ##2 2 US F 45 3 5 2 5 5MiddleAged
 ##3 3 UK F 25 3 5 5 5 2 Young
```


# Sorting data

```{r}
 order(leadership$age)
 ##[1]31425
 newdata2<-leadership[order(leadership$age),]
```


#Merging datasets
 
 To merge two dataframe horizontally,you use merge()function.In most cases,two
 data frames arejoined by one or more common key variables.-example1:
 merge(dataframeA,dataframeB,by=“ID”)-example2:
 merge(dataframeA,dataframeB,by=c(“ID”,“country”))
 
 the second merge the two dataframes by ID and country
 To join two data frame(datasets) vertically,use rbind()function:Note that the two
 dataset must have the same variables

# Subset(selecting variables,dropping variables,selecting observation)
```{r}
 newdata3<-leadership[,c(5:9)]
 myvars<-c("q1","q2","q3","q4","q5")
 newdata3<-leadership[myvars]
 newdata4<-leadership[,c(-1,-2)]
 newdata4<-leadership[,-(1:5)]
 newdata5<-leadership[,c(-1,-7)]
 leadership[[4]]
 ##[1]32452539NA
 leadership$age
 ##[1]32452539NA
 newdata6<-leadership[c(-1,-3),]
 newdata6<-leadership[c(2,4,5),]
 newdata7<-subset(leadership,age>=35|age<24,select=c(q1,q2,q3,q4,q5))
 attach(leadership)
 ##Thefollowingobjectsaremasked_by_.GlobalEnv:
 ##
 ## age,country,gender,manager,q1,q2,q3,q4,q5
 #newdata7<-leadership[gender="M"&age>30,]
 newdata7<-leadership[gender=="M"&age>30,]
 detach(leadership)
 
```

#  Datamanagement with dyplr
 Data source from the package nycflights13 and ggplot2 This data contains all
 336,776 flights that departed from New York city in 2013.
 
```{r}
#install.packages("nycflights13")
#install.packages("tidyverse")
 library(nycflights13)
 ##Warning:package'nycflights13'wasbuiltunderRversion4.2.3
 #install.packages("dplyr")
 library(dplyr)
 ##Warning:package'dplyr'wasbuiltunderRversion4.2.3
 ##
 ##Attachingpackage:'dplyr'
 ##Thefollowingobjectsaremaskedfrom'package:stats':
 ##
 ## filter,lag
 ##Thefollowingobjectsaremaskedfrom'package:base':
 ##
 ## intersect,setdiff,setequal,union
 #library(tidyverse)
```

# The function filter()

#rm(list=ls())
 
```{r}
str(flights)

```

```{r}

jan<-filter(flights,month==1)
 jan
 
newyear<-filter(flights,month==1,day==1)
 newyear
 
dec25<-filter(flights,month==12,day==25)
 dec25

jan_dec<-filter(flights,month==1|month==12)
 jan_dec
 
nov_dec<-filter(flights,month%in%c(11,12))
 #detach(flights)
```

# The function arrange()
 This change the order
 
```{r}
data_10<-arrange(flights,year,month,day)
 arrange(flights,desc(arr_delay))
```

# The function select
 This helps to selects only the variables you are interested in
 
```{r}
time_var<-select(flights,year,month,day)
select(flights,year:day)


select(flights,-(year:day))
```

#The function mutate
 This is useful in adding a newVariable
 
```{r}
##creating a small dataset
flights2<-select(flights,year:day,ends_with("delay"),distance,air_time)
 (mutate(flights2,gain=arr_delay-dep_delay,speed=distance/air_time*60))
```

# Control structures

# Grouping

Control structures in R allow you to control the flow of execution of a series of R
expressions. Basically, control structures allow you to put some “logic” into your R
code, rather than just always executing the same R code every time. Control
structures allow you to respond to inputs or to features of the data and execute
different R expressions accordingly. Commonly used control structures are • if and
else: testing a condition and acting on it • for: execute a loop a fixed number of times
• while: execute a loop while a condition is true • repeat: execute an infinite loop
(must break out of it to stop) • break: break the execution of a loop • next: skip an
interaction of a loop
if (condition){ ## do something } ## continue with the rest of the code.
if( condition){ do something
} else { do something else
}
You can also create a series of test by following the initial if with a number of else ifs
if(condition){ do something
}else if (condition 2){ Do something different }else{ do something different }

# Functions in R

```{r}
 f<-function(x) x^2
 formals(f)
 ## $x
 body(f)
 ## x^2
 environment(f)
 ## <environment: R_GlobalEnv>
```

#if else(test,yes,No)

```{r}

 pvalues<-c(.867,0.0054,0.0018,0.1572,0.0183,0.5386)
 results<-ifelse(pvalues<0.05,"Significant","Notsignificant")
 results
 ##[1]"Notsignificant""Significant" "Significant" "Notsignificant"
 ##[5]"Significant" "Notsignificant"
 x<-runif(1,0,10)
 if(x>3){
 y<-10
 }else{
 y<-0
 }
```

#The value of y is a set depending on whether x>3 or not.This canal so be achieved by

```{r}
y<-if(x>3){
 10
 }else{
 0
 }
```

####For

```{r}
for(i in 1:10){
 print(i)
}
 ##[1]1
 ##[1]2
 ##[1]3
 ##[1]4
 ##[1]5
 ##[1]6
 ##[1]7
 ##[1]8
 ##[1]9
 ##[1]10
 x<-c("a","b","c","d")
 x[3]
 ##[1]"c"
 for(i in 1:5){
   print(x[i])
 }
##[1]"a"
 ##[1]"b"
 ##[1]"c"
 ##[1]"d"
 ##[1]NA
 for(i in 1:5)print(1:i)
 ##[1]1
 ##[1]12
 ##[1]123
 ##[1]1234
 ##[1]12345
 for(i in 5:1)print(1:i)
 ##[1]12345
 ##[1]1234
 ##[1]123
 ##[1]12
 ##[1]1
```

# whileLoops
It begins by testing a condition,if it is true,then they execute the loop body.once the
loop body is executed,the condition is tested again,until the condition is false.after
which the loop exits

```{r}
count<-1
while(count<10){
 print(count)
 count<-count+1
}
 ##[1]1
 ##[1]2
 ##[1]3
 ##[1]4
 ##[1]5
 ##[1]6
 ##[1]7
 ##[1]8
 ##[1]9
 z<-5
 set.seed(1)
 while(z>=3&&z<=10){
 coin<-rbinom(1,1,0.5)
 if(coin==1){
 z=z+1
 }else{
z<-z-1
 }
 }
 print(z)
```

# next,break
 This is used to skip an iteration of a loop

```{r}
 for(i in 1:100){
 print(1:i)
 if(i>20){
 break
 }
 }
```

# Function

functionname<-function(parameters){statementsreturn(value)}

f1<-function(x){result<-x^2+2return(result)}

f2<-function(x,y){result<-x2+y2-4return(result)}

```{r}
 f<-function(x,y){
 result<-x+(2*y)+3
 return(result)
 }
f(2,3)
 ##[1]11
 f(2,3)
 ##[1]11
```

 You can use args()function to view the parameter names and default values
 
# Exercises
 Make functions that calculate summary statistics
 Make a function  to calculate two sample  t test


# Applying functions to matrices and data frame
```{r}
 a<-4
 sqrt(4)
 ##[1]2
 b<-c(1,243,5.754,2.987)
 round(b)
 ##[1] 1243 6 3
 c<-matrix(runif(12),nrow=3)
 c
 ## [,1] [,2] [,3] [,4]
 ##[1,]0.59956580.82737330.10794360.8209463
 ##[2,]0.49354130.66846670.72371090.6470602
 ##[3,]0.18621760.79423990.41127440.7829328
 log(c)
 ## [,1] [,2] [,3] [,4]
 ##[1,]-0.5115495-0.1894993-2.2261462-0.1972976
 ##[2,]-0.7061487-0.4027686-0.3233632-0.4353160
 ##[3,]-1.6808394-0.2303698-0.8884946-0.2447085
 mean(c)
 ##[1]0.5886061

```

 Notice that the mean of matrix c results in a scalar(0.444).the mean() take the
 average of all 12 elements in the matrix.But what if you want the three row means
 or the four column means?
 
 R provides a function,apply()that allows to apply an arbitrary function to any dimension of a matrix,array or data frame.The format for the apply()function is apply(x, MARGIN, FUN,…) where x stands for the data object, Margin can be 1(rows)
 and 2(columns ) ##Col/RowSums and Means
 • rowSums=apply(x, 1, sum) • row Means= apply(x, 1, mean)• colSums =apply(x, 2,
 sum) •colMeans= apply(x, 2, mean)



# lappy function
 
 lapply() takes three inputs:,x,a list,a function, and…, It applies to each element of the
 list and returns a new list. lapply(x,f,…). It is called function because it takes function
 as anargument. Assume wehaveadataframe df. instead of assigningthe result pf
 lappliy() to df, we will assign them to df[] to ensure we get a data frame.
```{r}
 fix_missing<-function(x){
 x[x==-99]<-NA
 x
 }
 function1<-function(x){
 x^2
 }
 curve(function1,-4,4)
```


```{r}
#df[]<-lappy(df,fix_missing)
```

It works for any number of columns.There is no way to accidentally miss a column

There is no way to accidentally treat one column differently than another

It easy to generalize this technique to a subset of columns

```{r}

 #df[1:5]<-lapply(df[1:5],fix_missing)
```

# sapply
 sapply()and vapply(),variants oflapply() that produces vectors,matrices,and
 arrays as Output,instead of lists map(),and mapply which iterate over multiple
 input datastructures inparallel
 
 Another important function when dealing with big data is split()-tapply
 
#Titanic data

```{r}
str(Titanic)
 ## 'table'num[1:4,1:2,1:2,1:2]0035000170118154...
 ##-attr(*,"dimnames")=Listof4
 ## ..$Class :chr[1:4]"1st""2nd""3rd""Crew"
 ## ..$Sex :chr[1:2]"Male""Female"
 ## ..$Age :chr[1:2]"Child""Adult"
 ## ..$Survived:chr[1:2]"No""Yes"
 View(Titanic)
 apply(Titanic,c(1,2),sum)
 ## Sex
 ##Class MaleFemale
 ## 1st 180 145
 ## 2nd 179 106
 ## 3rd 510 196
 ## Crew 862 23
 options(digits=2)
 apply(Titanic,c(1,2),sum)[3:4,]
 ## Sex
 ##Class MaleFemale
 ## 3rd 510 196
 ## Crew 862 23
 apply(Titanic,c(1,4),sum)[3:4,]
 ## Survived
 ##Class NoYes
 ## 3rd 528178
 ## Crew673212
 apply(Titanic,c(1,2,4),sum)
 ##,,Survived=No
 ##

  #apply(Titanic,c(1,2,4),sum)[3:4,]
 apply(Titanic,c(1,2,4),sum)[3:4,,]
 
 ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])
 ## SexMaleFemale
 ##ClassSurvived
 ##3rd No 422 106
 ## Yes 88 90
 ##Crew No 670 3
 ## Yes 192 20
 ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,]
 ## [,1][,2]
 ##[1,] 422 106
 ##[2,] 88 90
 ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,]

 digit=2
 prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,],margin=2)
 ## [,1][,2]
 ##[1,]0.830.54
 ##[2,]0.170.46
 prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,],margin=2)
 ## [,1][,2]
 ##[1,]0.780.13
 ##[2,]0.220.87
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,],margin=2),nrow=2,dimnames=list(dimnames(Titanic)$Survived,dimnames
 (Titanic)$Sex))
 ## MaleFemale
 ##No 0.83 0.54
 ##Yes0.17 0.46
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,],margin=2),nrow=2,dimnames=list(dimnames(Titanic)$Survived,dimnames
 (Titanic)$Sex))
 ## MaleFemale
 ##No 0.78 0.13
 ##Yes0.22 0.87
 ###Createdataset
 Student<-c("Johnncuti","Angelabakame","Brucewizeye","Alexisaganze
 ","claudeRukundo","JoelKagabo","Maryineza")
 Math<-c(600,412,358,495,512,410,522)
 Science<-c(95,99,80,82,75,89,77)
 English<-c(25,22,18,20,29,30,27)
 roster<-data.frame(Student,Math,Science,English,stringsAsFactors=FALSE)
 ###standardize variables and obtains the performance scores because they are reported on different scale (With widely differing means and standard deviations,we need to make them comparable before we combine them.)
 z<-scale(roster[,2:4])
###performance of each students using row means and adding them to roster using cbind()
 score<-apply(z,1,mean)
 roster<-cbind(roster,score)

 
###Grades the students:quantile function gives the percentile rank of each student's performance score check the cutoff of A
 y<-quantile(score,c(.8,.6,.4,.2))
 ##create a grade variable us
 roster$grade[score>=y[1]]<-"A"
 roster$grade[score<y[1]&score>=y[2]]<-"B"
 roster$grade[score<y[2]&score>=y[3]]<-"C"
 roster$grade[score<y[3]&score>=y[4]]<-"D"
 roster$grade[score<y[4]]<-"F"
 ####Dealing with names
 name<-strsplit((roster$Student),"")
 lastname<-sapply(name,"[",2)
 firstname<-sapply(name,"[",1)
 roster<-cbind(firstname,lastname,roster[,-1])
 roster<-roster[order(lastname,firstname),]
 roster
```


# Aggregationandreshaping

# transpose
```{r}
 cars<-mtcars[1:5,1:4]
 cars
 
 t(cars)
```


# aggregate data
 
aggregate() collapse data in R using one or more by variables and a defined function
```{r}
options(digits=3)
attach(mtcars)
aggdata<-aggregate(mtcars,by=list(cyl,gear),FUN=mean,na.rm=TRUE)
```

# Reshape

Step 1: install the package reshape2 step 2: melt data step 3: Cast the melted data
into any shape you desire

During the cast, you can aggregate the data with any function you wish.

```{r}
 id<-c(1,1,2,2)
 time<-c(1,2,1,2)
 x1<-c(5,3,6,2)
 x2<-c(6,5,1,4)
 mydata<-data.frame(id,time,x1,x2)
```



